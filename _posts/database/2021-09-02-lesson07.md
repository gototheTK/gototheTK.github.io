---
title: "데이터베이스 언어 SQL"
excerpt: "데이터베이스 언어 SQL"
layout: single
classes: wide
permalink: /database/lesson07
categories:
  - database
  - database language
tags:
  - database
  - database language
author_profile: false
sidebar:
  nav: database
---

## SQL의 역할을 이해하고, 이를 기능별로 분류해본다.

> SQL은 관계 데이터베이스를 위한 표준 데이터 언어 또는 표준 질의어이다. 여기서 질의어란 데이터 언어 중 검색 위주의 기능을 하는 비절차적 데이터 조작어를 의미한다. 그러나 SQL은 데이터 조작 기능과 정의 및 제어 기능까지 제공한다.

    데이터 정의어(DDL) : 테이블을 생성하고 변경 * 제거하는 기능을 제공한다.
    데이터 조작어(DML) : 테이블에 새 데이터를 삽입하거나, 테이블에 저장된 데이터를 수정, 삭제, 검색하는 기능을 제공한다.
    데이터 제어어(DCL) : 보안을 위해 데이터에 대한 접근 및 사용 권하을 사용자별로 부여하거나 취소하는 기능을 하는 언어다. 데이터베이스 관리자가 주로 사용한다.

## SQL의 데이터 정의 기능을 예제를 통해 익힌다.

    INT,INTEGER: 정수
    SAMLLINT: INT보다 작은 정수
    CHAR(n) or CHARACTER(n): 길이 n이 고정길이의 문자열
    VARCHAR(n) or CHARACTER VARYING(n): 최대 길이가 n인 가변 길이의 문자열
    NUMERIC(p, s) or DECIMAL : 고정 소수점 실수, p는 소수점을 제외한 전체 숫자의 길이고, s는 소수점 이하 숫자의 길이
    FLOAT(n) : 길이가 n인 부동 소수점 길이
    REAL : 부동 소수점 실수
    DATETIME or DATE : 년, 월 일로 표현되는 날짜
    TIME : 시, 분, 초로 표현되는 시간
    '' : 문자열을 표시하고 대소문자를 구분

    1. 테이블 생성(CREATE TABLE)

        CREATE TABLE 테이블_이름 (
            속성_이름 데이터_타입 [NOT NULL] [DEFAULT 기본_값]
            [PRIMARY KEY (속성_리스트)]
            [UNIQUE (속성_리스트)]
            [FOREIGN KEY (속성_리스트) REFERENCES 테이블_이름(속성_리스트)]
            [ON DELETE 옵션] [ON UPDATE 옵션]
            [CONSTRAINT 이름] [CHECK(조건)]
        )

        1. ON DELETE NO ACTION : 투플을 삭제하지 못하게함
        2. ON DELETE CASCADE : 관련 투플을 함께 삭제함
        3. ON DELETE SET NULL : 관련 투플의 외래키 값을 NULL로 변경함
        4. ON DELETE SET DEFAULT : 관련 투플의 값을 미리 지정한 기본 값으로 변경함

        예제1) 고객 테이블은 고객아이디, 고객이름, 나이, 직업, 적립금 속성으로 구성하고, 고객아이디 속성이 기본키다. 고객이름과 등급 속성은 값을 반드시 입력해야 하고, 적립금 속성은 값을 입력하지 않으면 0이 기본으로 입력되도록 고객 테이블을 생성해보자.
        CREATE TABLE 고객(
            고객아이디 VARCHAR2(20) NOT NULL,
            고객이름 VARCHAR2(20) NOT NULL,
            나이 INTEGER DEFAULT 0,
            등급 VARCHAR2(20) NOT NULL,
            직업 VARCHAR2(20),
            적립금 INTEGER,
            PRIMARY KEY (고객아이디)
        )

        예제2) 제품 테이블은 제품번호, 제품명, 재고량, 단가, 제고업체 속성으로 구성되고, 제품번호 속성이 기본키다. 재고량이 항상 0개 이상 10000개 이하를 유지하도록 제품 테이블을 생성해보자.

        CREATE TABLE 제품(
            제품번호 CHAR(3) NOT NULL,
            제품명 VARCHAR(20),
            재고량 INTEGER,
            단가 INTEGER,
            제조업체 VARCHAR(20),
            PRIMARY KEY(제품번호),
            CHECK (재고량 >= 0 AND 재고량 <= 10000)
        );

        예제3) 주문 테이블은 주문번호, 주문고객, 주문제품, 수량, 배송지, 주문일자 속성으로 구성되고, 주문번호 속성이 기본키다. 주문고객 속성이 고객 테이블의 고객아이디 속성을 참조하는 외래키이고, 주문제품 속성이 제품 테이블의 제품번호 속성을 참조하는 외래키가 되도록 주문 테이블을 생성해보자.

        CREATE TABLE 주문 (
            주문번호 VARCHAR(20) NOT NULL,
            주문고객 VARCHAR(20),
            주문제품 VARCHAR(20),
            수량 INTEGER,
            배송지 VARCHAR(20),
            주문일자 DATE
            PRIMARY KEY(주문번호),
            FOREGIN KEY(주문고객) REFERENCE 고객(고객아이디),
            FOREGIN KEY(주문제품) REFERENCE 제품(제품번호)
        );

    2. 테이블 변경(ALTER TABLE)

        2.1. 새로운 속성의 추가

        ALTER TABLE 테이블_이름
            ADD 속성_이름 데이터_타입 [NOT NULL] [DEFAULT 기본_값];

            예제7) 예제1)에서 생성한 고객 테이블에 가입날짜 속성을 추가해보자.

                ALTER TABLE 고객 ADD 가입날짜 DATETIME;

        2.2 기존 속성의 삭제

        ALTER TABLE 테이블_이름
            DROP 속성_이름 CASCADE | RESTRICT;

            예제8) 예제1)에서 생성한 고객 테이블의 등급 속성을 삭제하면서 관련된 제약조건이나 등급 속성을 참조하는 다른 속성도 함께 삭제해보자.

                ALTER TABLE 고객 DROP 등급 CASCADE;

        2.3 새로운 제약조건의 추가

            ALTER TABLE 테이블_이름 ADD CONSTRAINT 제약조건_이름 제약조건_내용;

            예제9) 고객 테이블에 20세 이상의 고객만 가입할 수 있다는 데이터 무결성 제약조건을 추가해보자.

                ALTER TABLE 고객 ADD CONSTRAINT CHK_AGE (나이>=20);

        2.4 기존 제약조건의 삭제

            ALTER TABLE 테이블_이름 DROP CONSTRAINT 제약조건_이름;

            예제9) 고객 테이블에 20세 이상의 고객만 가입할 수 있다는 데이터 무결성 제약조건을 삭제해보자.

                ALTER TABLE 고객 DROP CONSTRAINT CHK_AGE;

    3. 테이블 제거(DROP TABLE)

        DROP TABLE 테이블 CASCADE | RESTRICT;

        예제10) 고객 테이블을 삭제하되, 고객 테이블을 참조하는 다른 테이블이 존재하면 삭제가 수행되지 않도록 해보자.

            DROP TABLE 고객 RESTRICT;

## SQL의 데이터 조작 기능을 예제를 통해 익힌다.

    SQL의 데이터 조작 기능은 원하는 데이터 검색, 새로운 데이터 삽입, 데이터 수정, 데이터 삭제로 분류할 수 있다.

    SELECT [ALL |DISTINCT] 속성 리스트
    FROM 테이블_리스트
    [ WHERE 조건 ];

    예제 7-9)
        고객 테이블에서 고객아이디, 고객이름, 등급 속성을 검색해보자.
            SELECT 고객아이디, 고객이름, 등급, FROM 고객;

    예제 7-10)
        고객 테이블에 존재하는 모든 속성을 검색해보자.
            SELECT 고객아이디, 고객이름, 나이, 등급, 직업, 적립금
            FROM 고객;

    예제 7-21)
        고객 테이블에서 성이 김씨인 고객의 고객이름, 나이, 등급, 적립금을 검색해보자.
            SELECT 고객이름, 나이, 등급, 적립금 FROM 고객 LIKE '김%';

    예제 7-22)
        고객 테이블에서 고객아이디가 5자인 고객의 고객아이디, 고객이름, 등급을 검색해보자.
            SELECT 고객아이디, 고객이름, 등급 FROM 고객;

    예쩨 7-23)
        고객 테이블에서 나이가 아직 입력되지 않은 고객의 고객이름을 검색해보자.
            SELECT 고객이름 FROM 고객 WHERE 나이 IS NULL;

    예제 7-24)
        고객 테이블에서 나이가 아직 입력되지 않은 고객의 고객이름을 검색해보자.
            SELECT 고객이름 FROM 고객 WHERE 나이 IS NULL;

    예제 7-25)
        고객 테이블에서 나이가 이미 입력된 고객의 고객이름을 검색해보자.
            SELECT 고객이름 FROM 고객 WHERE 나이 IS NOT NULL;

    예제 7-25)
        고객 테이블에서 고객이름, 등급, 나이를 검색하되, 나이를 기준으로 내림차순 정렬해보자.
            SELECT 고객이름, 등급, 나이 FROM 고객 ODER BY 나이 DESC;

    예제 7-26)
        주문 테이블에서 수량이 10개 이상인 주문의 주문고객, 주문제품, 수량, 주문일자를 검색해보자. 단, 주문제품을 기준으로 오름차순 정렬하고, 동일 제품은 수량을 기준으로 내림차순 정렬해보자.
            SELECT 주문고객, 주문제품, 수량, 주문일자 WHERE 수량 >= 10 ORDER BY 주문제품 ASC, 수량 DESC.

    집계함수
        열 함수(COLUMN FUNCTION)라고도 하며, 개수, 합계, 평균, 최댓값, 최솟값의 계산 기능을 제공한다.
            COUNT : 속성 값의 개수 (모든 데이터)
            MAX : 속성 값의 최댓값 (모든 데이터)
            MIN : 속성 값의 최솟값 (모든 데이터)
            SUM : 속성 값의 합계 (숫자 데이터)
            AVG : 속송 값의 평균 (숫자 데이터)
        집계 함수는 NULL값을 제외하고, WHERE절에서는 사용할 수 없다. SELECT 절이나 HAVING 절에서만 사용이 가능하다.

    예제) 한빛제과에서 제조한 제품의 재고량 합계를 제품 테이블에서 검색해보자.
        SLEECT SUM(재고량) AS '재고량의 합계' FROM 한빛제과

    예제) 고객 테이블에 고객이 몇 명 등록되어 있는지 검색해보자.
        SELECT COUNT(고객아이디) FROM 고객;

    그룹별 검색
        SELECT |ALL|DISTINCT| 속성리스트
        FROM 테이블_리스트
        [WHERE 조건]
        [GROUP BY 속성_리스트|HAVING 조건]
        [ORDER BY 속성_리스트|ASC|DESC]

    예제) 주문 테이블에서 주문제품별 수량의 합계를 검색해보자.
        SELECT SUM(수량) FROM 주문;

    예제) 제품 테이블에서 제조업체별로 제조한 제품의 개수와 제품 중 가장 비싼 단가를 검색하되, 제품의 개수는 제품수라는 이름으로 출력하고 가장 비싼 단가는 최고가라는 이름으로 출력해보자.
        SELECT 제조업체, COUNT(*) AS 제품수, MAX(단가) AS 최고가
        FROM 제품
        GROUP BY 제조업체;

    예제) 제품 테이블에서 제품을 3개이상 제조한 제조업체별로 제품의 개수와, 제품 중 가장 비싼 단가를 검색해보자.
        SELECT 제조업체 ,COUNT(*) AS 제품의 개수, MAX(단가) AS 최고 단가 FROM 제품 GROUP BY 제조업체 HAVING COUNT(제조업체) >= 3;

    예제) 고객 테이블에서 적립금 평균이 1000원 이상인 등급에 대해 등급별 고객 수와 적립금 평균을 검색해보자.
        SELECT 등급, COUNT(고객), AVG(적립금) AS 적립금평균 GROUP BY 등급 HAVING 1000 > AVG(적립금);

    예제) 주문 테이블에서 각 주문고객이 주문한 제품의 총주문수량을 주문제품별로 검색해보자.

        SELECT 주문제품,주문고객, SUM(*) AS 총 주문수량 GROUP BY 주문제품;

    조인 검색
        여러 테이블을 연결하여 데이터를 검색하는 방법을 조인 검색이라고한다.

    예제1) 주문 데이터베이스에서 banana 고객이 주문한 제품의 이름을 검색해보자.
        SELECT 주문.제품이름 FROM 주문, 고객 WHERE 판매.제품번호 = 주문.제품번호;

    예제2) 판매 데이터베이스에서 나이가 30세  이상의 고객이 주문한 제품의 주문제품과 주문일자를 검색해보자.
        SELECT 주문.주문제품, 주문.주문일자 FROM 주문, 고객 WHERE 고객.나이 >= 30 AND 주문.고객아이디 = 고객.고객아이디;

    예제3) 판매 데이터베이스에서 고명석 고객이 주문한 제품의 제품명을 검색해보자.
        SELECT P.제품명 FROM 고객 C, 제품 P, 주문 O WHERE C.고객이름 = '고명석' AND C.고객아이디 = O.고객아이디 AND O.주문제품 = P.제품번호;

    부속 질의문

    쿼리안에 또다른 쿼리가 있는경우가 있는데, 이 안에있는 질의문을 부속 질의문이라고한다. 이 부속 질의문은 서브 질의문이라고도 하는데, ORDER BY를 쓸수없으며 결과가 하나뿐일 경우 단일 행 부속질의문이라고하고 결과가 여러개인 경우의 질의문을 다중 행 부속질의문이라고한다.
    바깥 질의문을 상위 질의문이라고하는데, 부속질의문이 실행되고 결과값이 나온뒤에 상위 질의문이 실행된다. 부속질의문의 결과값으로 상위질의문을 실행하고 연산할경우, 단일 행 부속질의문이라면 일반연산자를 쓰고 다중 행 부속질의문이라면 논리연산자를 주로쓴다.

    예제1) 판매 데이터베이스에서 달콤비슷켓과 같은 제조업체에서 제조한 제품의 제품명과 단가를 검색해보자.

        SELECT 제품명, 단가 FROM 제품 WHERE 제조업체 = (SELECT 제조업체 FROM 판매 WHERE 제품명 = '달콤비스켓');

    예제2) 판매 데이터베이스에서 적립금이 가장 많은 고객의 고객이름과 적립금을 검색해보자.

        SELECT 고객이름, 적립금 FROM 판매 WHERE 적립금 = (SELECT MAX(적립금) FROM 고객);

    예제3) 판매 데이터베이스에서 banana 고객이 주문한 제품의 제품명과 제조업체를 검색해보자.

        SELECT 제품명, 제조업체 FROM 제품 WHERE 제품번호 IN(SELECT 주문제품 FROM 판매 WHERE 주문고객 = 'banana');

    예제4) 판매 데이터베이스에서 banana 고객이 주문하지 않는 제품의 제품명과 제조업체를 검색해보자.

        SELECT 제품명, 제조업체 FROM 제품 WHERE 제품번호 NOT IN(SELECT 주문제품 FROM 주문 WHERE 주문고객 = 'banana');

    예제5) 판매 데이터베이스에서 대한식품이 제조한 모든 제품의 단가보다 비싼 제품의 제품명, 단가, 제조업체를 검색해보자.

        SELECT 제품명, 단가, 제조업체 FROM 제품 WHERE 제품번호 > ALL (SELECT 제품번호 FROM 제품 WHERE 회사명 = '대한식품');

    예제6) 판매 데이터베이스에서 2013년 3월 15일에 제품을 주문한 고객의 고객이름을 검색해보자.

        SELECT 고객이름 FROM 고객 WHERE EXIST (SELECT * FROM 주문 WHERE 주문일자 = '2013-03-15' AND 고객.주문고객 = 고객.고객아이디);

    예제7) 판매 데이터베이스에서 2013녀 3월 15일에 제품을 주문하지 않는 고객의 고객이름을 검색해보자.

        SELECT 고객이름 FROM 고객 WHERE NOT EXIST(SELECT * FROM 주문 WHERE 주문일자 = '2013-03-15' AND 주문.주문고객 = 고객.고객아이디);

        데이터 삽입

        - 데이터 직접삽입
        INSERT INTO 테이블_이름[(속성리스트)] VALUES (속성값리스트);

        예제1) 판매 데이터베이스의 고객 테이블에 고객아이디가 strawberry, 고객이름이 최유경, 나이가 30세, 등급이 vip, 직업이 공무원, 적립금이 100원인 새로운 고객의 정보를 삽입해보자. 그런 다음 고객 테이블에 있는 모든 내용을 검색하여 삽입된 새로운 투플을 확인해보자.

            INSERT INTO 고객(고객아이디, 고객이름, 나이, 등급, 직업, 적립금) VALUES('strawberry', 최유경, 30, 'vip', '공무원', 100)

            SELECT * FROM 고객;

        예제2) 판매 데이터베이스의 고객 테이블에 고객아이디가 tomato, 고객이름이 정은심, 나이가 36세, 등급이 gold, 적립금이 4000원, 직업은 아직 모르는 새로운 고객의 정보를 삽입해보자. 그런 다음 고객 테이블에 있는 모든 내용을 검색하여 삽입된 정은심 고객의 직업 속성이 널값인지 확인해보자.

            INSERT INTO 고객(고객아이디, 고객이름, 정은심, 나이, 등급, 적립금)
            VALUES('tomato', 정은심, 36, 'gold', 4000);

            SELECT * FROM 고객;

        - 부속 질의문을 이용한 데이터 삽입

        판매 데이터베이스에서 제시한 세 개의 테이블 외에 제품명 * 재고량 * 단가 속성으로 구성된 한빛제품 테이블이 존재한다고 가정하고, 부속 질의문을 이용한 INSERT 문의 예를 살펴보자.

            INSERT INTO 한빛제품(제품명, 재고량, 단가) SELECT 제품명, 재고량 ,단가 FROM 제품 WHERE 제품업체 = '한빛제과';

    데이터의 수정

        UPDATE 테이블_이름
        SET 속성이름1 = 값1, 속성이름2 = 값2
        [WHERE 조건];

        WHERE절의 조건에 맞는 투플들의 속성값을 수정한다. 만약 WHERE절이 없다면 모든 투플들이 수정된다.

        예제1) 제품 테이블에서 제품번호가 P03인 제품의 제품명을 통큰파이로 수정해보자. 그런 다음 제품 테이블의 모든 내용을 검색하여 수정 내용을 확인해보자.

            UPDATE 제품 SET 제품명='통큰파이' WHERE 제품번호 = 'P03';

        예제2) 제품 테이블에 있는 모든 제품의 단가를 10% 인상해보자. 그런 다음 제품 테이블의 모든 내용을 검색하여 인상 내용을 확인해보자.

            UPDATE 제품 SET 단가 = 단가 * 1.1;
            SELECT * FROM 제품;

        예제3) 판매 데이터베이스에서 정소화 고객이 주문한 제품의 주문수량을 5개로 수정해보자. 그런 다음 주문 테이블의 모든 내용을 검색하여 수정 내용을 확인해보자.

            UPDATE 주문 SET 주문수량 = 5 WHERE 주문고객 IN (SELECT 고객아이디 FROM 고객 WHERE 고객이름 = '정소화');
            SELECT * FROM 주문;

    데이터의 삭제

        DELETE
        FROM 테이블이름
        [WHERE 조건];

        테이블에서 조건에 맞는 투플들을 삭제한다. 조건을 걸지않으면 테이블의 모든 투플이들이 사라지게된다.

        예제1) 주문 테이블에서 주문일자가 2013년 5월 22일인 주문내역을 삭제해보자. 그런 다음 주문 테이블의 모든 내용을 검색하여 삭제 여부를 확인해보자.

            DELETE FROM 주문 WHERE 주문일자 = '2013-05-22';
            SELECT * FROM 주문;

        예제2) 판매 데이터베이스의 주문 테이블에 존재하는 모든 투플을 삭제해보자. 그런 다음 주문 테이블의 모든 내용을 검색하여 삭제 여부를 확인해보자.

            DELETE FROM 주문;
            SELECT * FROM 주문;

        예제3) 판매 데이터베이스에서 정소화 고객이 주문한 내역을 주문 테이블에서 삭제해보자. 그런 다음 주문 테이블의 모든 내용을 검색하여 삭제 여부를 확인해보자.

            DELETE FROM 주문 WHERE 주문고객 IN (SELECT 고객아이디 FROM 고객 WHERE 고객이름 = '정소화');
            SELECT * FROM 주문;




    - 조건에서 NULL은 FALSE이다. 그리고 오름차순에서는 마지막, 내림차순에서는 맨처음 등장한다.
    - 그룹별로 검색할 때는 집계 함수나 GROUP BY 절에 있는 속성 외의 속성은 SELECT 절에 사용 할 수 없다.

## 뷰의 개념과 장점을 이해한다.

    뷰(VIEW)란?
        실제로 존재하는 기본 테이블들을 기반으로 만든 물리적 저장소에 저장되지 않고 논리적으로만 존재하는 가상테이블이다. 즉, 실제로 존재하지 않는 테이블이다. 그렇기때문에 뷰를 통해 기본테이블을 변경시키는건 아주 제한적이다.
        참고로, 뷰(VIEW)의 생성과 삭제는 데이터 정의기능에 해당한다.

    뷰의 생성

        CREATE VIEW 뷰_이름[(속성_리스트)]
        AS SELECT 문
        [WITH CHECK OPTION];

        CREATE VIEW로 뷰이름과 나열할 속성들을 정의하고, AS SELECT로 기본 테이블을 제시한다. 나열할 속성들을 정의하지 않을경우 기본테이블을 기반으로 AS ASELECT로 제시된 속성들이 전부 나열된다.
        WITH CHECK OPTION은 생략이 가능하며, 생성한 뷰에 삽입이나 수정연산을 할경우 SELECT문의 정의조건을 만족하지않으면 수행하지 않도록하는 제약조건을 제시한다.

        예제1) 고객 테이블에서 등급이 VIP인 고객의 고객아이디, 고객이름, 나이로 구성된 뷰를 우수고객이라는 이름으로 생성해보자. 그런 다음 우수고객 뷰의 모든 내용을 검색해보자.

            CREATE VIEW 우수고객(고객아이디, 고객이름, 나이)
            AS SELECT 고객아이디, 고객이름, 나이
            FROM 고객 WHERE 등급 = 'VIP'
            WITH CHECK OPTION;

        예제2) 제품 테이블에서 제조업체별 제품수로 구성된 뷰를 업체별제품수라는 이름으로 생성해보자. 그런 다음 업체별제품수 뷰의 모든 내용을 검색해보자.

            CREATE VIEW 업체별제품수(제조업체, 제품수)
            AS SELECT 제조업체, COUNT(*) FROM 제품 GROUP BY 제조업체
            WITH CHECK OPTION;

            SELECT * FROM 업체별제품수;

    뷰의 활용

        CREATE VIEW로 만들어진 VIEW는 테이블처럼 데이터를 검색할수있다.
        뷰를 미리 만들어놓으면 특정 조건을 만족하는 데이터를 검색하는 쉽게 작성할수 있고, 제공된 뷰를 통해서만 접근하도록 접근권한을 설정하면 사용자로부터 데이터를 보호할수있다. 그리고 기본테이블의 다른 부분이나 뷰와 관련없는 테이블에 신경쓰지 않아도 되니 데이터 관리에도 편리하다.

        참고로 뷰의 변경을 통해 기본테이블을 부분적으로 변경가능하다고 했는데,
        뷰 변경이 불가능한 경우는 다음과 같다.

        - 기본테이블의 기본키를 구성하는 속성이 뷰에 포함되지않은 경우
        - 기본테이블에 있던 내용이 아니라 집계 함수로 새로 계산된 내용을 포함하고 있는 경우
        - DISTINCT 키워드를 포함하여 정의한 뷰를 정의한 경우
        - GROUP BY 절을 포함하여 뷰를 정의한 경우
        - 여러 개의 테이블을 조인하여 뷰를 정의한 경우

        예제1) 우수고객 뷰에서 나이가 25세 이상인 고객에 대한 모든 내용을 검색해보자.

            SELECT * FROM 우수고객 WHERE 나이 >= 25;

        예제2) 제품 테이블에서 제품번호, 재고량, 제조업체 속성으로 구성된 제품 1뷰와, 제품명 * 재고량 * 제조업체 속성으로 구성된 제품2 뷰를 다음과 같이 생성하고 확인해보자.

            CREATE VIEW 제품1
            AS SELECT 제품번호, 재고량, 제조업체
                FROM 제품
            WITH CHECK OPTION;

            SELECT * FROM 제품1;

            CREATE VIEW 제품2
            AS SELECT 제품명, 재고량, 제조업체
                FROM 제품
            WITH CHECK OPTION;

            SELECT * FROM 제품2;

        예제3) 제품번호가 P08, 재고량이 1000, 제조업체가 신선식품인 새로운 제품의 정보를 제품1 뷰에 삽입해보자. 그런 다음 제품1 뷰에 있는 모든 내용을 검색해보자.

            INSERT INTO 제품1(제품번호, 재고량, 제조업체) VALUES('P08', 1000, '신선식품');
            SELECT * FROM 제품1;

    뷰의 삭제

        DROP VIEW 뷰_이름 CASCADE | RESTRICT;

        뷰를 삭제할경우 기본테이블은 영향을 받지않는다. 그러나 삭제할 뷰를 통해 만들어진 뷰가 존재하고 함께 삭제할경우 질의문에 CASCADE를 지정한다. 삭제할 뷰를 통해 만들어진 뷰가 있는 경우에 삭제하고싶지 않다면 RESTRICT를 지정하면 된다.

        예제1) 우수고객 뷰를 삭제하되, 우수고객 뷰를 이용하는 다른 뷰가 존재하면 삭제가 수행되지 않도록 해보자.

            DROP VIEW 우수고객 RESTRICT

## 삽입 SQL의 역할을 이해한다.

    삽입 SQL이란?
        DBMS로 바로 수행결과를 볼수있는 대화식 SQL이 아니라, C,C++,JAVA로 작성된 응용프로그램에 직접 삽입하는 SQL을 삽입 SQL이라고 한다.
        일반 명령문이 위치할 수 있는 곳이면 어디든 삽입 가능하고, 일반 명령문과 구분하기 위해 삽입 SQL 문앞에 EXEC SQL을 붙인다. 프로그램에 선언된 일반 변수를 SQL문에서 사용할수 있는데, SQL문에서 사용할때 일반 변수 앞에 :을 붙여 구분한다.
        결과행의 하나냐 여러개냐에 따라 반환된 행을 한번에 하나씩 가리키는 커서를 이용하는데, CREATE TABLE, ISNERT, DELETE, UPDATE, 행 하나를 결과로 반환하는 SELECT같이 결과 행이 하나 일때 사용하고, 결과행이 여러개인경우에 커서를 사용한다.

## 연습문제

    문제1) 뷰를 생성하기 위한 기본 형식 중 WITH CHECK OPTION의 의미를 설명하시오.
        뷰에 투플을 삽입하거나 수정할때, 투플이 뷰의 정의조건을 만족하는지 검사하도록하는 지정어이다.

    문제2) 다음 두 테이블을 보고 각 물음에 답하시오
    환자테이블
        환자번호/환자이름/나이/담당의사
            p001/   오우진/ 31/ D002
            p002/   채광주/ 50/ D001
            p003/   김용육/ 43/ D003

    의사 테이블
        의사번호/의사이름/소속/근무연수
            D001/   정지영/ 내과/   5
            D002/   김선주/ 피부과/ 10
            D003/   정성호/ 정형외과/ 15

        (1) 환자 테이블을 생성하는 SQL 문을 작성하시오. (단, 이름 속성은 널 값이 허용되지 않도록 지정하고, 담당의사 속성을 의사테이블의 의사번호 속성을 참조하는 외래키로 지정하시오.)

            CREATE TABLE 환자 (VARCARH 환자, VARCHAR 환자이름 NOT NULL, INT 나이, VARCHAR 의사이름, PRIMARY KEY(환자), FOREIGN KEY(의사이름) REFERENCES 의사(의사이름) );

        (2) 의사 테이블을 생성하는 SQL 문을 작성하시오. (단, 소속 속성의 값을 입력하지 않으면 자동으로 내과가 지정되도록 하고, 근무연수는 1년 이상 40년 이하의 범위의 값을 가지도록 지정하시오.)

            CREATE TABLE 의사 (VARCHAR 의사번호, VARCHAR 의사이름, VARCHAR 소속, INT 근무연수, PRIMARY KEY(의사번호), FOREGIN KEY(의사이름) DEFAULT '내과', CHECK (근무연수 >= 1 AND 근무연수 <40));

        (3) D001 의사가 담당하고 나이가 30세 이상인 환자의 환자번호와 환자이름을 검색하는 SQL문을 작성하시오.

            SELECT 환자번호, 환자이름 FROM 환자 WHERE 담당의사 = 'DOO1' AND 나이 >= 30);

        (4) 소속별로 의사의 수와 평균 근무연수를 검색하는 SQL 문을 작성하시오.

            SELECT COUNT(*) AS '의사의 수', AVG(근무연수) AS'평균 근무연수' FROM 의사;

        (5) 김용욱 환자를 담당하는 의사의 의사이름과 소속, 근무연수를 검색하는 SQL 문을 작성하시오.

            SELECT 의사이름, 소속, 근무연수 FROM 의사 WHERE 의사번호 = (SELECT 담당의사 FROM 환자 WHERE 환자이름 = '김용욱');

    문제3) 다음 세개의 테이블 스키마를 보고 각 물음에 답하시오.

        학생(★학번, 이름, 학년)
        과목(★과목번호, 과목이름)
        수강(★학번, ★과목번호, 중간성적, 기말성적, 학점)

        (1) 수강 테이블에서 L자로 시작하는 과목의 중간성적이 90점 이상인 학생의 이름과 기말성적을 검색하는 SQL문을 작성하시오. (단, 이름을 기준으로 오름차순 정렬하고, 만약 이름이 같으면 기말성적을 기준으로 내림차순 정렬하시오.)

            SELECT S.학생, L.기말성적  FROM 학생 AS S LEFT JOIN 수강 AS L ON S.학번 = L.학번 ON S.학번 = L.학번 WHERE S.과목번호 IN (SELECT * FROM 과목 WHERE 과목이름= L%) AND S.중간성적 >= 90;

        (2) 수강 테이블에서 2명 이상의 학생이 수강하는 과목에 대해 과목별 등록 학생의 수와 중간성적의 평균을 구하는 SQL문을 작성하시오. 이때, 등록한 학생의 총 수는 '학생수'로, 중간성적의 평균은 '성적평균'으로 속성 이름을 새로 부여하시오.

            SELECT COUNT(학번) AS '학생수', AVG(중간성적) AS '성적평균' FROM 수강 GROUP BY 과목번호 HAVING COUNT(학번) > 2;

        (3) 수강 테이블에서 개설된 과목의 수를 검색하는 SQL문을 작성하시오.

        (4) L001 과목을 수강하지 않는 학생의 이름과 학년을 검색하는 SQL문을 작성하시오. (단, IN 연산자를 이용해 작성하시오.)

        (5) L001 과목을 수강하지 않는 학생의 이름과 학년을 검색하는 SQL문을 작성하시오. (단 EXIST 연산자를 이용해 작성하시오.)

    문제4)
